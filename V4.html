<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>圖片排版工具</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f8f8f8; }
    #image-list {
      display: grid;
      grid-template-columns: repeat(4, 512px);
      grid-template-rows: repeat(3, 293px);
      gap: 35px 0;
      width: 2048px;
      height: calc(3 * 293px + 2 * 35px);
      margin-bottom: 20px;
      background: white;
    }
    .thumb {
      width: 512px;
      height: 293px;
      overflow: hidden;
      position: relative;
      border: 1px solid #ccc;
      background: #fff;
    }
    .thumb img {
      position: absolute;
      top: 50%; left: 50%;
      max-width: 100%;
      max-height: 100%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .thumb[draggable] {
      cursor: grab;
    }
    .dragging {
      opacity: 0.4;
    }
    .dragging img {
      opacity: 0.4;
    }
    .insert-line {
      width: 4px;
      background-color: red;
      height: 100%;
      position: absolute;
      top: 0;
      z-index: 10;
    }
    .delete-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(255, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 16px;
      cursor: pointer;
      z-index: 20;
    }
    .selected {
      border: 4px solid red;
      box-sizing: border-box;
    }
    #canvas-preview {
      border: 1px solid #999;
      margin-top: 20px;
      background: white;
      max-width: 100%;
    }
    button, select {
      margin: 5px;
      padding: 8px 16px;
      font-size: 16px;
    }
    #edit-status {
      font-weight: bold;
      color: #d00;
    }
  </style>
</head>
<body>
  <h2>圖片排版工具（3 行 4 欄）</h2>
  <h3>1.可多次上傳圖片</h3>
  <h3>2.拖曳排序（紅線顯示插入點 + 半透明）</h3>
  <h3>3.右上角「×」可刪除圖片</h3>
  <h3>4.點選「編輯模式」可點兩張圖片交換位置</h3>
  <h3 id="edit-status"></h3>

  <input type="file" id="file-input" multiple accept="image/*">
  <button onclick="toggleEditMode()">切換編輯模式</button>
  <button onclick="generateImage()">產生合成圖</button>
  <button onclick="downloadImage()">下載圖片</button>
  <div id="image-list"></div>
  <canvas id="canvas-preview" width="2048" height="1015"></canvas>

  <script>
    const input = document.getElementById('file-input');
    const list = document.getElementById('image-list');
    const canvas = document.getElementById('canvas-preview');
    const ctx = canvas.getContext('2d');
    const editStatus = document.getElementById('edit-status');

    let editMode = false;
    let selectedThumb = null;

    function toggleEditMode() {
      editMode = !editMode;
      selectedThumb = null;
      document.querySelectorAll('.thumb').forEach(t => t.classList.remove('selected'));
      editStatus.textContent = editMode ? '編輯模式啟用：點選兩張圖片可交換' : '';
    }

    input.addEventListener('change', (e) => {
      const files = Array.from(e.target.files).slice(0, 12);
      files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          const img = document.createElement('img');
          img.onload = () => {
            const wrapper = document.createElement('div');
            wrapper.className = 'thumb';
            wrapper.setAttribute('draggable', 'true');

            const delBtn = document.createElement('button');
            delBtn.className = 'delete-btn';
            delBtn.textContent = '×';
            delBtn.onclick = (e) => {
              e.stopPropagation();
              wrapper.remove();
            };

            wrapper.addEventListener('click', () => {
              if (!editMode) return;
              if (wrapper === selectedThumb) {
                wrapper.classList.remove('selected');
                selectedThumb = null;
              } else if (selectedThumb === null) {
                selectedThumb = wrapper;
                wrapper.classList.add('selected');
              } else {
                const thumb1 = selectedThumb;
                const thumb2 = wrapper;
                const next1 = thumb1.nextSibling;
                const next2 = thumb2.nextSibling;

                if (next1 === thumb2) {
                  list.insertBefore(thumb2, thumb1);
                } else if (next2 === thumb1) {
                  list.insertBefore(thumb1, thumb2);
                } else {
                  list.insertBefore(thumb2, next1);
                  list.insertBefore(thumb1, next2);
                }

                thumb1.classList.remove('selected');
                thumb2.classList.remove('selected');
                selectedThumb = null;
              }
            });

            wrapper.appendChild(delBtn);
            wrapper.appendChild(img);
            list.appendChild(wrapper);
            enableDragDrop();
          };
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      });
      e.target.value = '';
    });

    function enableDragDrop() {
      let dragged = null;
      let insertLine = document.createElement('div');
      insertLine.className = 'insert-line';

      list.querySelectorAll('.thumb').forEach(item => {
        item.addEventListener('dragstart', (e) => {
          dragged = item;
          item.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', '');
        });

        item.addEventListener('dragend', () => {
          if (dragged) dragged.classList.remove('dragging');
          if (insertLine.parentNode) insertLine.remove();
        });

        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          const target = item;
          if (target === dragged) return;

          const rect = target.getBoundingClientRect();
          const offset = e.clientX - rect.left;
          const before = offset < rect.width / 2;

          if (insertLine.parentNode) insertLine.remove();
          insertLine.style.left = before ? '0px' : 'unset';
          insertLine.style.right = before ? 'unset' : '0px';
          target.style.position = 'relative';
          target.appendChild(insertLine);
        });

        item.addEventListener('dragleave', () => {
          if (insertLine.parentNode) insertLine.remove();
        });

        item.addEventListener('drop', (e) => {
          e.preventDefault();
          const target = item;
          if (insertLine.parentNode) insertLine.remove();
          if (target === dragged) return;

          const rect = target.getBoundingClientRect();
          const offset = e.clientX - rect.left;
          const before = offset < rect.width / 2;

          if (before) {
            list.insertBefore(dragged, target);
          } else {
            list.insertBefore(dragged, target.nextSibling);
          }
        });
      });

      enableTouchDrag(); // 手機拖曳支援
    }

    function enableTouchDrag() {
      let touchStartEl = null;
      let currentOverEl = null;
      let insertLine = document.createElement('div');
      insertLine.className = 'insert-line';

      list.querySelectorAll('.thumb').forEach(item => {
        item.addEventListener('touchstart', (e) => {
          touchStartEl = item;
          item.classList.add('dragging');
        });

        item.addEventListener('touchmove', (e) => {
          if (!touchStartEl) return;

          const touch = e.touches[0];
          const el = document.elementFromPoint(touch.clientX, touch.clientY);
          const thumb = el?.closest('.thumb');

          if (!thumb || thumb === touchStartEl) return;

          if (currentOverEl !== thumb) {
            currentOverEl = thumb;
            const rect = thumb.getBoundingClientRect();
            const offset = touch.clientX - rect.left;
            const before = offset < rect.width / 2;

            if (insertLine.parentNode) insertLine.remove();
            insertLine.style.left = before ? '0px' : 'unset';
            insertLine.style.right = before ? 'unset' : '0px';
            thumb.style.position = 'relative';
            thumb.appendChild(insertLine);
          }
        });

        item.addEventListener('touchend', (e) => {
          if (touchStartEl && currentOverEl && currentOverEl !== touchStartEl) {
            const rect = currentOverEl.getBoundingClientRect();
            const touch = e.changedTouches[0];
            const offset = touch.clientX - rect.left;
            const before = offset < rect.width / 2;

            if (before) {
              list.insertBefore(touchStartEl, currentOverEl);
            } else {
              list.insertBefore(touchStartEl, currentOverEl.nextSibling);
            }
          }

          touchStartEl?.classList.remove('dragging');
          if (insertLine.parentNode) insertLine.remove();
          touchStartEl = null;
          currentOverEl = null;
        });
      });
    }

    function generateImage() {
      const baseWidth = 2048;
      const baseHeight = 1015;

      canvas.width = baseWidth;
      canvas.height = baseHeight;

      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, baseWidth, baseHeight);

      const thumbs = list.querySelectorAll('.thumb img');

      Promise.all(Array.from(thumbs).map(img => {
        return new Promise(resolve => {
          if (img.complete) resolve();
          else img.onload = resolve;
        });
      })).then(() => {
        thumbs.forEach((img, index) => {
          const row = Math.floor(index / 4);
          const col = index % 4;
          const cellWidth = 512;
          const cellHeight = 293;
          const x = col * cellWidth;
          const y = 33 + row * (cellHeight + 35);

          const s = Math.min(cellWidth / img.naturalWidth, cellHeight / img.naturalHeight);
          const w = img.naturalWidth * s;
          const h = img.naturalHeight * s;
          const dx = x + (cellWidth - w) / 2;
          const dy = y + (cellHeight - h) / 2;

          ctx.drawImage(img, dx, dy, w, h);
        });
      });
    }

    function downloadImage() {
      const link = document.createElement('a');
      link.download = 'merged-image.jpg';
      link.href = canvas.toDataURL('image/jpeg', 0.95);
      link.click();
    }
  </script>
</body>
</html>
